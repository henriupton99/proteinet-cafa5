"""FUNCTIONS FOR GENERATING THE LABELS TAGRETS FOR ALL ASPECTS
"""
import pandas as pd
import numpy as np
from tqdm import tqdm
import re
import gc

def extract_go_terms_and_branches(
    file_path : str
    ) -> dict:
    """Utilitary function to construct a mapping {GO TERM : ASPECT} for each GO TERM in input OBO file

    Args:
        file_path (str): file path for input GO terms

    Returns:
        go_terms_dict (dict): mapping dictionnary
    """
    with open(file_path, 'r') as file:
        content = file.read()
        stanzas = re.findall(r'\[Term\][\s\S]*?(?=\n\[|$)', content)
    go_terms_dict = {}
    for stanza in stanzas:
        go_id = re.search(r'^id: (GO:\d+)', stanza, re.MULTILINE)
        if go_id:
            go_id = go_id.group(1)
        namespace = re.search(r'^namespace: (\w+)', stanza, re.MULTILINE)
        if namespace:
            namespace = namespace.group(1)
        if go_id and namespace:
            branch_abbr = {'biological_process': 'BPO', 'cellular_component': 'CCO', 'molecular_function': 'MFO'}
            go_terms_dict[go_id] = branch_abbr[namespace]

    return go_terms_dict

def generate_labels_matrix(
    ids : np.ndarray,
    labels_names : list[str],
    id_labels : dict,
    go_terms_map : dict
    ):
    """Utilitary function to generate labels target matrix given :
    - protein ids, labels_names (GO terms names)
    - id labels : id of labels
    - go terms map generated by function extract_go_terms_and_branches

    """
    labels_matrix = np.zeros((len(ids), len(labels_names)))
    
    for index, id in tqdm(enumerate(ids)):
        try :
            id_gos_list = id_labels[id]
            temp = [go_terms_map[go] for go in labels_names if go in id_gos_list]
            labels_matrix[index, temp] = 1
        except:
            pass
        
    return labels_matrix

def generate_targets(
    ids_path : str,
    labels_path : str,
    weights_path : str,
    go_obo_path : str,
    evidence_codes_path : str,
    targets_path : str,
    aspects_list : str,
    go_terms_per_aspects : dict[int]
    ):
    """Function to generate labels (targets) for a given aspect (BPO, CCO, or MFO) for each protein id in ids, based on labels dataframe.
    NB : For memory usage and models precision reasons, we only consider a subset of all GO terms labels
    We consider to top K most frequent for each aspect (based on go_terms_per_aspects input dictionnary)

    Args:
        ids_path (str): path to protein ids 
        labels_paths (str): path to labels annotations dataframe for each protein in ids
        weights_path (str): path to IA weights for GO terms metric computation
        go_obo_path (str) : path to obo graph file
        evidence_codes_path (str) : path to evidence codes to filter for EXP GO terms
        targets_path (str) : path where to save the target labels
        aspects_list (str): list of aspects to consider
        go_terms_per_aspects (dict[int]): number of GO term classes to consider per aspect
    """
    ids = np.load(ids_path)
    labels = pd.read_csv(labels_path, sep = "\t")
    colnames = ["term", "weight"]
    ia_weights = pd.read_csv(weights_path, sep = "\t", names = colnames, header=None)
    evidence_codes = pd.read_parquet(evidence_codes_path)
    evidence_codes = evidence_codes[evidence_codes["EvidenceCode"].notnull()]["term"].unique().tolist()
    
    for aspect in aspects_list:
        print("="*25)
        print("START LOADING FOR ASPECT {}".format(aspect))
        aspects_labels = labels[labels["aspect"] == aspect]
        aspects_labels = aspects_labels[aspects_labels["term"].isin(evidence_codes)]
        top_terms = aspects_labels.groupby("term")["EntryID"].count().sort_values(ascending=False).to_frame()
        map_go_terms_aspects = extract_go_terms_and_branches(
                                file_path=go_obo_path
                                )
        top_terms["aspect"] = top_terms.index.map(map_go_terms_aspects)
        labels_names = top_terms[:go_terms_per_aspects[aspect]]
        labels_names = labels_names.index.values
        weights_df = pd.DataFrame(data={"term" : labels_names})
        weights_df = weights_df.merge(ia_weights, on = "term", how = "left")
        print("NUMBER OF GO TERMS IN {} SUBSET : {}".format(aspect,str(len(labels_names))))
        train_labels_sub = labels[(labels.term.isin(labels_names)) & (labels.EntryID.isin(ids))]
        id_labels = train_labels_sub.groupby('EntryID')['term'].apply(list).to_dict()
        go_terms_map = {label: i for i, label in enumerate(labels_names)}
        labels_matrix = generate_labels_matrix(
            ids=ids,
            labels_names=labels_names,
            id_labels=id_labels,
            go_terms_map=go_terms_map
        )
        labels_list = []
        for l in range(labels_matrix.shape[0]):
            labels_list.append(labels_matrix[l, :])

        labels_df = pd.DataFrame(data={"EntryID":ids, "labels_vect":labels_list})
        labels_df.to_pickle(targets_path + "/train_targets_{}.pkl".format(aspect))
        weights_df.to_csv(targets_path + "/weights_{}.csv".format(aspect),index=None)
        del aspects_labels, labels_df, weights_df, labels_list, labels_matrix, go_terms_map
        gc.collect()
        print("GENERATION FINISHED FOR ASPECT {}".format(aspect))
    
    del ids, labels, ia_weights, evidence_codes
    gc.collect()
    print("GENERATION FINISHED ! :D")
    return 